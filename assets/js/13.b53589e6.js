(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{283:function(v,l,i){"use strict";i.r(l);var n=i(14),_=Object(n.a)({},(function(){var v=this,l=v._self._c;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("p",[v._v("###Java并发笔记")]),v._v(" "),l("p",[v._v("Synchronized问题")]),v._v(" "),l("ul",[l("li",[v._v("Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例。")]),v._v(" "),l("li",[v._v("Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。")]),v._v(" "),l("li",[v._v("Synchronized有什么样的缺陷? Java Lock是怎么弥补这些缺陷的。")]),v._v(" "),l("li",[v._v("Synchronized和Lock的对比，和选择?")]),v._v(" "),l("li",[v._v("Synchronized在使用时有何注意事项?")]),v._v(" "),l("li",[v._v("Synchronized修饰的方法在抛出异常时,会释放锁吗?")]),v._v(" "),l("li",[v._v("多个线程等待同一个Synchronized锁的时候，JVM如何选择下一个获取锁的线程?")]),v._v(" "),l("li",[v._v("Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?")]),v._v(" "),l("li",[v._v("我想更加灵活的控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办?")]),v._v(" "),l("li",[v._v("什么是锁的升级和降级? 什么是JVM里的偏向锁、轻量级锁、重量级锁?")]),v._v(" "),l("li",[v._v("不同的JDK中对Synchronized有何优化?")])]),v._v(" "),l("p",[v._v("对象锁\n包括方法锁(默认锁对象为this,当前实例对象)和同步代码块锁(自己指定锁对象)\n代码块形式：手动指定锁定对象，也可是是this,也可以是自定义的锁\n方法锁形式：synchronized修饰普通方法，锁对象默认为this")]),v._v(" "),l("p",[v._v("类锁\n指synchronize修饰静态的方法或指定锁对象为Class对象\nsynchronize修饰静态方法\nsynchronized指定锁对象为Class对象")]),v._v(" "),l("p",[v._v("加锁和释放锁的原理\nMonitorenter和Monitorexit指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一：")]),v._v(" "),l("ul",[l("li",[v._v("monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待")]),v._v(" "),l("li",[v._v("如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加")]),v._v(" "),l("li",[v._v("这把锁已经被别的线程获取了，等待锁释放\nmonitorexit指令：释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。")])]),v._v(" "),l("p",[v._v("可重入原理：加锁次数计数器\n与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。\n可重入锁：又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。")]),v._v(" "),l("p",[v._v("保证可见性的原理：内存模型和happens-before规则\nSynchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。")]),v._v(" "),l("p",[v._v("锁的类型\n在Java SE 1.6里Synchronied同步锁，一共有四种状态：无锁、偏向锁、轻量级锁、重量级锁，它会随着竞争情况逐渐升级。锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。\n锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)")]),v._v(" "),l("p",[v._v("使用Synchronized有哪些要注意的？")]),v._v(" "),l("ul",[l("li",[v._v("锁对象不能为空，因为锁的信息都保存在对象头里")]),v._v(" "),l("li",[v._v("作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错")]),v._v(" "),l("li",[v._v("避免死锁")]),v._v(" "),l("li",[v._v("在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错\n锁的优缺点对比\n锁\t优点\t缺点\t使用场景\n偏向锁\t加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距\t如果线程间存在锁竞争，会带来额外的锁撤销的消耗\t适用于只有一个线程访问同步块的场景\n轻量级锁\t竞争的线程不会阻塞，提高了响应速度\t如线程始终得不到锁竞争的线程，使用自旋会消耗CPU性能\t追求响应时间，同步块执行速度非常快\n重量级锁\t线程竞争不使用自旋，不会消耗CPU\t线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗\t追求吞吐量，同步块执行速度较长")])]),v._v(" "),l("p",[v._v("volatile问题")]),v._v(" "),l("ul",[l("li",[v._v("volatile关键字的作用是什么?")]),v._v(" "),l("li",[v._v("volatile能保证原子性吗?")]),v._v(" "),l("li",[v._v("之前32位机器上共享的long和double变量的为什么要用volatile? 现在64位机器上是否也要设置呢?")]),v._v(" "),l("li",[v._v("i++为什么不能保证原子性?")]),v._v(" "),l("li",[v._v("volatile是如何实现可见性的? 内存屏障。")]),v._v(" "),l("li",[v._v("volatile是如何实现有序性的? happens-before等")]),v._v(" "),l("li",[v._v("说下volatile的应用场景?")])]),v._v(" "),l("p",[v._v("volatile的作用详解\n防重排序\n一个最经典的例子，单例模式的实现，在并发环境下的单例实现方式，我们通常可以采用双重检查加锁(DCL)的方式来实现。在变量singleton之前加上volatile关键字。实例化一个对象其实可以分为三个步骤：")]),v._v(" "),l("ul",[l("li",[v._v("分配内存空间。")]),v._v(" "),l("li",[v._v("初始化对象。")]),v._v(" "),l("li",[v._v("将内存空间的地址赋值给对应的引用。\n但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：")]),v._v(" "),l("li",[v._v("分配内存空间。")]),v._v(" "),l("li",[v._v("将内存空间的地址赋值给对应的引用。")]),v._v(" "),l("li",[v._v("初始化对象\n如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。\n实现可见性\n可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题\n保证原子性:单次读/写\nvolatile不能保证完全的原子性，只能保证单次的读/写操作具有原子性。")])]),v._v(" "),l("p",[v._v("volatile 的实现原理")]),v._v(" "),l("p",[v._v("volatile 可见性实现\nvolatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现:\nlock 前缀的指令在多核处理器下会引发两件事情:")]),v._v(" "),l("ul",[l("li",[v._v("将当前处理器缓存行的数据写回到系统内存。")]),v._v(" "),l("li",[v._v("写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。\n如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。\nvolatile 有序性实现\nvolatile 的 happens-before 关系\nhappens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。\nvolatile 禁止重排序\n为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。\nJava 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。")])]),v._v(" "),l("p",[v._v("volatile 的应用场景\n使用 volatile 必须具备的条件")]),v._v(" "),l("ul",[l("li",[v._v("对变量的写操作不依赖于当前值。")]),v._v(" "),l("li",[v._v("该变量没有包含在具有其他变量的不变式中。")]),v._v(" "),l("li",[v._v("只有在状态真正独立于程序内其他内容时才能使用 volatile。")])]),v._v(" "),l("p",[v._v("final问题")]),v._v(" "),l("ul",[l("li",[v._v("所有的final修饰的字段都是编译期常量吗?")]),v._v(" "),l("li",[v._v("如何理解private所修饰的方法是隐式的final?")]),v._v(" "),l("li",[v._v("说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做? 外观模式。（组合代替继承）")]),v._v(" "),l("li",[v._v("final方法可以被重载吗? 可以")]),v._v(" "),l("li",[v._v("父类的final方法能不能够被子类重写? 不可以")]),v._v(" "),l("li",[v._v("说说final域重排序规则?")]),v._v(" "),l("li",[v._v("说说final的原理?")]),v._v(" "),l("li",[v._v("使用 final 的限制条件和局限性?")])]),v._v(" "),l("p",[v._v("说说final的原理?")]),v._v(" "),l("ul",[l("li",[v._v("写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。")]),v._v(" "),l("li",[v._v("读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。")])]),v._v(" "),l("p",[v._v("final重排序规则\n按照final修饰的数据类型分类：")]),v._v(" "),l("ul",[l("li",[v._v("基本数据类型:\n"),l("ul",[l("li",[v._v("final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。")]),v._v(" "),l("li",[v._v("final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。")])])]),v._v(" "),l("li",[v._v("引用数据类型：\n"),l("ul",[l("li",[v._v("额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序")])])])]),v._v(" "),l("p",[v._v("JUC\n线程安全的实现方法有哪些?\n线程安全的实现方法包含:")]),v._v(" "),l("ul",[l("li",[v._v("互斥同步: synchronized 和 ReentrantLock")]),v._v(" "),l("li",[v._v("非阻塞同步: CAS, AtomicXXXX")]),v._v(" "),l("li",[v._v("无同步方案: 栈封闭，Thread Local，可重入代码\n什么是CAS?\nCAS的全称为Compare-And-Swap，直译就是对比交换。是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值，经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。   简单解释：CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。\nCAS操作是原子性的，所以多线程并发使用CAS更新数据时，可以不使用锁。JDK中大量使用了CAS来更新数据而防止加锁(synchronized 重量级锁)来保持原子更新。")])]),v._v(" "),l("p",[v._v("AQS")]),v._v(" "),l("ul",[l("li",[v._v("什么是AQS? 为什么它是核心?")]),v._v(" "),l("li",[v._v("AQS的核心思想是什么? 它是怎么实现的? 底层数据结构等")]),v._v(" "),l("li",[v._v("AQS有哪些核心的方法?")]),v._v(" "),l("li",[v._v("AQS定义什么样的资源获取方式? AQS定义了两种资源获取方式：独占(只有一个线程能访问执行，又根据是否按队列的顺序分为公平锁和非公平锁，如ReentrantLock) 和共享(多个线程可同时访问执行，如Semaphore、CountDownLatch、 CyclicBarrier )。ReentrantReadWriteLock可以看成是组合式，允许多个线程同时对某一资源进行读。")]),v._v(" "),l("li",[v._v("AQS底层使用了什么样的设计模式? 模板")]),v._v(" "),l("li",[v._v("AQS的应用示例?")])])])}),[],!1,null,null,null);l.default=_.exports}}]);