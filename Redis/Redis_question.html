<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis | 凡事发生必有利于我</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/docs/favicon.ico">
    <meta name="description" content="凡事发生必有利于我的随记">
    <meta name="author" content="Salvatore">
    <meta name="keywords" content="算法刷题记录，编程语言技术文档，面试八股记录，凡事发生必有利于我">
    
    <link rel="preload" href="/docs/assets/css/0.styles.732fc518.css" as="style"><link rel="preload" href="/docs/assets/js/app.b07d6ba1.js" as="script"><link rel="preload" href="/docs/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/docs/assets/js/16.f8cf6a48.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.8492f219.js"><link rel="prefetch" href="/docs/assets/js/11.6905d251.js"><link rel="prefetch" href="/docs/assets/js/12.1b3c29cb.js"><link rel="prefetch" href="/docs/assets/js/13.b53589e6.js"><link rel="prefetch" href="/docs/assets/js/14.c522d284.js"><link rel="prefetch" href="/docs/assets/js/15.eca51f4c.js"><link rel="prefetch" href="/docs/assets/js/17.ff61d613.js"><link rel="prefetch" href="/docs/assets/js/18.1f35ee57.js"><link rel="prefetch" href="/docs/assets/js/19.1a474624.js"><link rel="prefetch" href="/docs/assets/js/20.b6dcdfa4.js"><link rel="prefetch" href="/docs/assets/js/21.51cd363f.js"><link rel="prefetch" href="/docs/assets/js/22.214deb13.js"><link rel="prefetch" href="/docs/assets/js/3.d9b695e0.js"><link rel="prefetch" href="/docs/assets/js/4.d12742be.js"><link rel="prefetch" href="/docs/assets/js/5.216cae74.js"><link rel="prefetch" href="/docs/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/docs/assets/js/7.f68a0bec.js"><link rel="prefetch" href="/docs/assets/js/8.690aa5e4.js"><link rel="prefetch" href="/docs/assets/js/9.f316d8c0.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.732fc518.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><img src="/docs/assets/img/logo.png" alt="凡事发生必有利于我" class="logo"> <span class="site-name can-hide">凡事发生必有利于我</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/docs/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/docs/about.html" class="nav-link">
  About
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">Languages</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/cpp.html" class="nav-link">
  C++
</a></li><li class="dropdown-item"><!----> <a href="/docs/go.html" class="nav-link">
  Go
</a></li><li class="dropdown-item"><!----> <a href="/docs/java.html" class="nav-link">
  Java
</a></li><li class="dropdown-item"><!----> <a href="/docs/python.html" class="nav-link">
  Python
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="DB" class="dropdown-title"><span class="title">DB</span> <span class="arrow down"></span></button> <button type="button" aria-label="DB" class="mobile-dropdown-title"><span class="title">DB</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/Mysql/Mysql_question.html" class="nav-link">
  Mysql
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Cache" class="dropdown-title"><span class="title">Cache</span> <span class="arrow down"></span></button> <button type="button" aria-label="Cache" class="mobile-dropdown-title"><span class="title">Cache</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/Redis/Redis_question.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Redis
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Tools" class="dropdown-title"><span class="title">Tools</span> <span class="arrow down"></span></button> <button type="button" aria-label="Tools" class="mobile-dropdown-title"><span class="title">Tools</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/Tools/tmux.html" class="nav-link">
  Tmux
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/docs/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/docs/about.html" class="nav-link">
  About
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">Languages</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/cpp.html" class="nav-link">
  C++
</a></li><li class="dropdown-item"><!----> <a href="/docs/go.html" class="nav-link">
  Go
</a></li><li class="dropdown-item"><!----> <a href="/docs/java.html" class="nav-link">
  Java
</a></li><li class="dropdown-item"><!----> <a href="/docs/python.html" class="nav-link">
  Python
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="DB" class="dropdown-title"><span class="title">DB</span> <span class="arrow down"></span></button> <button type="button" aria-label="DB" class="mobile-dropdown-title"><span class="title">DB</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/Mysql/Mysql_question.html" class="nav-link">
  Mysql
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Cache" class="dropdown-title"><span class="title">Cache</span> <span class="arrow down"></span></button> <button type="button" aria-label="Cache" class="mobile-dropdown-title"><span class="title">Cache</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/Redis/Redis_question.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Redis
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Tools" class="dropdown-title"><span class="title">Tools</span> <span class="arrow down"></span></button> <button type="button" aria-label="Tools" class="mobile-dropdown-title"><span class="title">Tools</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/Tools/tmux.html" class="nav-link">
  Tmux
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Redis</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/Redis/Redis_question.html#redis面试" class="sidebar-link">Redis面试</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/docs/Redis/Redis_question.html#redis使用场景" class="sidebar-link">Redis使用场景</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/Redis/Redis_question.html#一些具体使用场景" class="sidebar-link">一些具体使用场景</a></li><li class="sidebar-sub-header"><a href="/docs/Redis/Redis_question.html#缓存" class="sidebar-link">缓存</a></li><li class="sidebar-sub-header"><a href="/docs/Redis/Redis_question.html#分布式锁" class="sidebar-link">分布式锁</a></li></ul></li><li><a href="/docs/Redis/Redis_question.html#其他面试题" class="sidebar-link">其他面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/Redis/Redis_question.html#集群" class="sidebar-link">集群</a></li><li class="sidebar-sub-header"><a href="/docs/Redis/Redis_question.html#事务" class="sidebar-link">事务</a></li><li class="sidebar-sub-header"><a href="/docs/Redis/Redis_question.html#redis为什么快" class="sidebar-link">Redis为什么快</a></li><li class="sidebar-sub-header"><a href="/docs/Redis/Redis_question.html#看完回答下这些问题" class="sidebar-link">看完回答下这些问题</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="redis面试"><a href="#redis面试" class="header-anchor">#</a> Redis面试</h2> <p><img src="/docs/assets/Redis/img/overview.png" alt="overview"></p> <h2 id="redis使用场景"><a href="#redis使用场景" class="header-anchor">#</a> Redis使用场景</h2> <h3 id="一些具体使用场景"><a href="#一些具体使用场景" class="header-anchor">#</a> 一些具体使用场景</h3> <ul><li>计数器（incr命令）</li> <li>保存token（String）</li> <li>消息队列（List）</li> <li>延迟队列（Zset）</li></ul> <h3 id="缓存"><a href="#缓存" class="header-anchor">#</a> 缓存</h3> <p>击穿、缓存、穿透 双写一致性、持久化 数据过期、淘汰策略</p> <h4 id="缓存穿透-大量请求mysql也不存在的数据-此时redis缓存中自然也没有这个数据-此时会导致每次请求都需要查询数据库。"><a href="#缓存穿透-大量请求mysql也不存在的数据-此时redis缓存中自然也没有这个数据-此时会导致每次请求都需要查询数据库。" class="header-anchor">#</a> 缓存穿透：大量请求mysql也不存在的数据，此时Redis缓存中自然也没有这个数据，此时会导致每次请求都需要查询数据库。</h4> <p>简单解决方案</p> <ul><li>接口层增加校验</li> <li>缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存，优化：设置超时时间（不超过5分钟）
<ul><li>优点：简单</li> <li>缺点：如果key值变化频繁，会导致 Redis 中缓存大量无效的 key，内存消耗严重，并且出现不一致问题
<ul><li>不一致原因：如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致</li> <li>解决：利用消息队列或者其它异步方式清理缓存中的空对象。</li></ul></li></ul></li></ul> <p>主流解决方法</p> <ul><li>布隆过滤器
<ul><li>将所有可能存在的数据hash到一个足够大的bitmap中(bitmap数组中只能存0或1)</li> <li>作用：用于检索一个元素是否在一个集合中</li> <li>影响误判的因素（影响Hash碰撞）
<ul><li>Hash函数的个数</li> <li>位数组的长度（数组越大误判率越小，但是会带来更多内存消耗）</li></ul></li> <li>种类
<ul><li>Google的Guava，存储在JVM</li> <li>分布式，存储在Redis位图</li></ul></li> <li>优点：内存占用较少，没有多余key</li> <li>缺点：存在误判，且难以维护（数据不能删除，需要定时更新数据即重建）</li></ul></li></ul> <p><img src="/docs/assets/Redis/img/bloom_filter.png" alt="bloom_filter"></p> <h4 id="缓存击穿-某个热点key过期失效的时候-恰好有大量并发请求访问这个key-瞬间把db击垮。"><a href="#缓存击穿-某个热点key过期失效的时候-恰好有大量并发请求访问这个key-瞬间把db击垮。" class="header-anchor">#</a> 缓存击穿：某个热点key过期失效的时候，恰好有大量并发请求访问这个key，瞬间把DB击垮。</h4> <ul><li>简单解决方案</li> <li>逻辑过期（不设置过期时间）
<ul><li>在value中添加expire字段记录过期时间，通过异步的⽅式不断的刷新过期时间（通知一个异步线程刷新缓存），在刷新成功前请求的都是过期数据。</li> <li>不能保证数据强一致性，好处是高可用，性能也较优</li></ul></li></ul> <p>主流解决方案</p> <ul><li>分布式锁（互斥锁）
<ul><li>⽐如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写⼊缓存，再返回给⽤户，这样后⾯的请求就可以从缓存中拿到数据了</li> <li>可以保证数据的强一致性，但相对性能差</li></ul></li></ul> <h4 id="缓存雪崩-同一时段的大量缓存key同时失效或者redis服务宕机-导致大量请求到数据库-带来巨大压力"><a href="#缓存雪崩-同一时段的大量缓存key同时失效或者redis服务宕机-导致大量请求到数据库-带来巨大压力" class="header-anchor">#</a> 缓存雪崩：同一时段的大量缓存key同时失效或者Redis服务宕机，导致大量请求到数据库，带来巨大压力</h4> <p>解决方案</p> <ul><li>给缓存key添加随机因子，分散失效时间</li> <li>利用Redis集群提高服务高可用
<ul><li>哨兵模式</li> <li>集群模式</li></ul></li> <li>给业务添加多级缓存
<ul><li>第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同</li> <li>Guava、Caffine做一级缓存，Redis做二级缓存</li></ul></li> <li>给缓存业务添加降级限流策略（保底策略）
<ul><li>当出现大量缓存失效，而且处在高并发高负荷的情况下，在业务系统内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的 fallback（退路）错误处理信息</li> <li>ngnix或spring cloud gateway</li></ul></li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>穿透无中生有key，布隆过滤null隔离。</p> <p>缓存击穿过期key，锁与非期解难题。</p> <p>雪崩大量过期key，过期时间要随机。</p> <p>面试必考三兄弟，可用限流来保底。</p></div> <h4 id="双写一致性"><a href="#双写一致性" class="header-anchor">#</a> 双写一致性</h4> <p>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&amp;mid=2247487312&amp;idx=1&amp;sn=fa19566f5729d6598155b5c676eee62d&amp;chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&amp;scene=178&amp;cur_album_id=1699766580538032128#rd" target="_blank" rel="noopener noreferrer">缓存与数据库一致性问题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>数据一致性在指的是缓存双写一致性，由于想要提高应用的性能，可以引入「缓存」来解决</p> <p>引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」</p> <ul><li>更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，且存在「缓存资源浪费」和「机器性能浪费」的情况发生</li> <li>在更新数据库 + 删除缓存的方案中，
<ul><li>「先删除缓存，再更新数据库」在「并发」场景下依旧有数据不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估，所以推荐用「先更新数据库，再删除缓存」的方案</li> <li>「先更新数据库，再删除缓存」方案下，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据一致性</li> <li>「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率</li> <li>因此最终解决的方案取决于业务背景对一致性的要求
<ul><li>一致性要求不高（允许延迟一致性）
<ul><li>延迟双删：先删缓存再更新数据库，等几百毫秒再删缓存 (延迟时间根据具体的业务耗时而定)（面试喜欢问，但是不常用）</li> <li>使用中间件如消息队列（MQ）或订阅变更日志（阿里巴巴的canal）（可达到<strong>最终一致性</strong>）
<ul><li>引入消息队列：把要删除的key或者删除失败的key丢进消息队列，利用消息队列的重试机制，重试删除对应的key。</li> <li>订阅变更日志：用一个服务（阿里的 canal）去监听数据库的binlog，获取需要操作的数据，然后用一个公共的服务获取订阅程序传来的信息，进行缓存删除操作，这种方式对业务代码侵入性很低，因为canal是基于mysql主从复制用到的binlog来操作的。</li></ul></li></ul></li> <li>一致性要求高（强一致、但性能低）
<ul><li>Redission中的读写锁readLock、writeLock，读共享，写互斥</li></ul></li></ul></li></ul></li></ul> <p>问：redis作为缓存，mysql的数据如何与redis进行同步呢？（双写一致性）</p> <p>回答时要设置前提，<strong>一定</strong>要先介绍自己的<strong>业务背景</strong></p> <ul><li>一致性要求高</li> <li>允许延迟一致性</li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>redis做为缓存，mysql的数据如何与redis进行同步呢？（双写一致性）</strong></p> <ol><li>介绍自己简历上的业务，我们当时是把文章的热点数据存入到了缓存中，虽然是热点数据，但是实时要求性并没有那么高，所以，我们当时采用的是异步的方案同步的数据</li> <li>我们当时是把抢券的库存存入到了缓存中，这个需要实时的进行数据同步，为了保证数据的强一致，我们当时采用的是redisson提供的读写锁来保证数据的同步</li></ol> <p><strong>那你来介绍一下异步的方案（你来介绍一下redisson读写锁的这种方案）</strong></p> <ul><li><strong>允许延时一致的业务</strong>，采用异步通知
<ol><li>使用MQ中间中间件，更新数据之后，通知缓存删除</li> <li>利用canal中间件，不需要修改业务代码，伪装为mysql的一个从节点，canal通过读取binlog数据更新缓存</li></ol></li> <li><strong>强一致性的</strong>，采用Redisson提供的读写锁
<ol><li>共享锁：读锁readLock，加锁之后，其他线程可以共享读操作</li> <li>排他锁：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作</li></ol></li></ul></div> <h4 id="持久化"><a href="#持久化" class="header-anchor">#</a> 持久化</h4> <p>使用缓存的时候，我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了做数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）。</p> <p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p> <ul><li>快照（snapshotting，RDB）</li> <li>只追加文件（append-only file, AOF）</li> <li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li></ul> <p><u>RDB(Redis Database Backup file)（数据备份文件），也被叫做数据快照，把内存中的所有数据都记录到磁盘中，当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。</u></p> <ul><li><p>原理</p> <ul><li>Redis会单独创建(fork)一个与当前进程一模一样的子进程来进行持久化，将数据写入到一个临时文件中，待持久化结束后替换上次持久化好的文件。
<ul><li>相当于两个redis进程，这期间主进程不参与持久化，保证了redis的高性能</li></ul></li> <li>fork的时候底层Linux使用的copy on write技术，即写时复制
<ul><li>当主进程执行读操作时，访问共享内存</li> <li>当主进程执行写操作时，则会拷贝一份数据，执行写操作</li></ul></li></ul></li> <li><p>触发</p> <ul><li>客户端执行shutdown命令时，如果没有开启aof时会触发</li> <li>配置文件中(redis.conf)快照配置， 有三个默认配置
<ul><li>save 900 1（15分钟内有1次修改）</li> <li>save 300 10（5分钟内有1次修改）</li> <li>save 60 10000（1分钟内有1次修改）</li></ul></li> <li>执行save或bgsave命令
<ul><li>save 由Redis主进程来执行RDB</li> <li>bgsave开启子进程执行RDB，避免主进程受到影响</li></ul></li> <li>bgsave会fork子进程异步持久化</li> <li>执行flushall命令
<ul><li>清空内存中的数据，同时触发持久化，清空磁盘</li></ul></li></ul></li> <li><p>特点</p> <ul><li>优点：恢复的时候比较快，适合大规模的数据恢复</li> <li>缺点
<ul><li>如遇突然宕机，丢失的数据比较多</li> <li>如果生成的快照文件比较大会影响redis性能</li></ul></li></ul></li></ul> <p><u>AOF（Append Only File、只追加文件），Redis处理的每一个写命令都会记录在AOF文件，可以看作是命令日志文件。</u></p> <ul><li><p>原理</p> <ul><li>将所有的写命令追加到AOF缓冲区中，根据对应的写入策略向硬盘进行同步操作
<ul><li>由主进程完成</li></ul></li> <li>AOF文件存的是顺序命令序列</li> <li>随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的
<ul><li>fork子进程来进行</li></ul></li> <li>持久化文件可以在redis.conf中配置：appendfilename &quot;append only.aof&quot;</li></ul></li> <li><p>触发</p> <ul><li>默认情况下Redis没有开启AOF方式的持久化（Redis6.0之后已经默认开启了），可以通过appendonly参数开启，在redis.conf中配置</li> <li>手动开启：appendonly yes # 默认是no
<ul><li>线上开启：CONFIG SET append only yes，避免丢失数据</li> <li>开启后redis会保留一块内存供缓冲区使用，默认是1M</li> <li>AOF和RDB同时开启时，只保留save 900 1减少fork子进程的次数</li></ul></li> <li>写入/刷盘策略：在redis.conf中配置，默认是appendsync everysec
<ul><li>everysec：写命令执行完先放入AOF缓冲区，然后每隔一秒将缓冲区数据写到AOF文件
<ul><li>效率高，可能会丢失1秒的数据【默认也推荐使用】</li></ul></li> <li>no：写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘、
<ul><li>次数少，效率高，不安全「追求效率」</li></ul></li> <li>always：每执行一次写命令，立即记录到AOF文件
<ul><li>效率低，安全「追求安全」</li></ul></li></ul></li> <li>重写机制
<ul><li>通过bgrewrite命令，可以让AOF文件执行重写功能
<ul><li>set num 123、set name jack、set num 666 =》mset name jack num 666</li></ul></li> <li>在redis.conf中配置重写触发机制</li> <li>默认配置
<ul><li>auto-aof-rewrite-min-size 64M
<ul><li>当文件大小大于等于64MB时触发重写</li> <li>优化：由于重写会fork子进程，为了减少重写次数，可以配置为5GB以上</li></ul></li> <li>auto-aof-rewrite-percentage 100
<ul><li>指文件比上次文件增长超过100个percent（即一倍）时触发重写</li></ul></li></ul></li></ul></li></ul></li> <li><p>特点</p> <ul><li>优点
<ul><li>以append-only模式写入，没有磁盘寻址开销，写入性能高，数据完整性高</li> <li>相比于RDB，丢失的数据更少</li></ul></li> <li>缺点
<ul><li>不适合冷备，恢复文件大，恢复速度慢</li></ul></li></ul></li></ul> <p><u>混合持久化（AOF+RDB）</u></p> <ul><li>配置 在redis.conf中配置aof-use-rdb-preamble yes，Redis5.0以后默认开启</li> <li>优化重写机制
<ul><li>重写后新的AOF文件前半段是RDB格式的全量数据，后半段是AOF格式的增量数据</li></ul></li> <li>特点
<ul><li>优点
<ul><li>由于绝大部分都是RDB格式，加载速度快</li> <li>同时结合AOF，增量数据得以保存，数据更少丢失</li></ul></li> <li>缺点
<ul><li>兼容性差，4.0之前不支持</li> <li>可读性差</li></ul></li></ul></li></ul> <p>Redis启动后持久化文件的加载流程：</p> <ul><li>先判断时候开启了AOF
<ul><li>如果存在AOF文件，则直接加载AOF文件</li> <li>如果找不到AOF文件，则直接启动，不会加载RDB文件</li></ul></li> <li>如果没有开启AOF，则会去加载RDB文件，通过RDB来持久化数据</li> <li>生产环境建议AOF和RDB同时使用，RDB做容灾备份</li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>redis做为缓存，数据的持久化是怎么做的？</strong></p> <p>在Redis中提供了两种数据持久化的方式：1、RDB 2、AOF</p> <p><strong>这两种持久化方式有什么区别呢？</strong></p> <p>RDB是一个快照文件，它是把redis内存存储的数据写到磁盘上，当redis实例宕机恢复数据的时候，方便从RDB的快照文件中恢复数据。
AOF的含义是追加文件，当redis操作写命令的时候，都会存储这个文件中，当redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据.</p> <p><strong>这两种方式，哪种恢复的比较快呢？</strong></p> <p>RDB因为是二进制文件，在保存的时候体积也是比较小的，它恢复的比较快，但是它有可能会丢数据，我们通常在项目中也会使用AOF来恢复数据，虽然AOF恢复的速度慢一些，但是它丢数据的风险要小很多，在AOF文件中可以设置刷盘策略，我们当时设置的就是每秒批量写入一次命令.</p></div> <h4 id="过期数据删除策略"><a href="#过期数据删除策略" class="header-anchor">#</a> 过期数据删除策略</h4> <ul><li>惰性删除
<ul><li>当需要改key时才检查其是否过期，若过期则删除，反之返回改key</li> <li>优点：对CPU友好，只会在使用到该key时才会进行过期检查，对于很多用不到的key不浪费时间进行过期检查</li> <li>缺点：对内存不友好，可能存在大量过期key，内存不被释放</li></ul></li> <li>定期删除
<ul><li>每隔一段时间，就随机抽取一些key进行检查，删除里面过期的key</li> <li>优点：通过限制删除操作执行的时常和频率来减少删除操作对CPU的影响，通过定时删除来有效释放过期key占用的内存</li> <li>缺点：难以确定删除操作执行的时长和频率</li></ul></li></ul> <p>Redis实际上是<strong>惰性删除+定期删除</strong>两种策略进行配合使用。</p> <p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p> <p>怎么解决这个问题呢？答案就是：<strong>Redis内存数据淘汰机制。</strong></p> <h4 id="内存数据淘汰机制"><a href="#内存数据淘汰机制" class="header-anchor">#</a> 内存数据淘汰机制</h4> <p><strong>使用命令动态配置：config set maxmemory-policy &lt;策略&gt;</strong></p> <p>Redis提供了8种不同的数据淘汰策略</p> <ul><li>allkeys-lru：从数据集中挑选<strong>最近最少使用</strong>的数据淘汰（<strong>留最常使用</strong>）</li> <li>allkeys-random：从数据集中<strong>任意选择</strong>数据淘汰</li> <li>volatile-lru：从<strong>已设置过期时间</strong>的数据集中挑选<strong>最近最少使用</strong>的数据淘汰</li> <li>volatile-random：从<strong>已设置过期时间</strong>的数据集中<strong>任意选择</strong>数据淘汰</li> <li>volatile-ttl：从<strong>已设置过期时间</strong>的数据集中<strong>挑选</strong>将要过期的数据淘汰</li> <li>no-enviction：禁止驱逐数据，再写入会<strong>报错</strong>（默认不回收）</li> <li>volatile-lfu: 在<strong>已设置过期时间</strong>的键上，应用LFU（<strong>最近最少频率被使用</strong>）策略</li> <li>allkeys-lfu: 在所有键上，应用LFU（<strong>最近最少频率被使用</strong>）策略</li></ul> <p>LRU(Least Recently Used)：最近最长时间未被使用，这个主要针对的是使用时间</p> <p>LFU(Least Frequently Used)：最近最少频率被使用，这个主要针对的是使用频率</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>关于数据淘汰策略其他的面试问题</p> <p><strong>数据库有1000万数据 ,Redis只能缓存20w数据, 如何保证Redis中的数据都是热点数据 ?</strong></p> <p>使用allkeys-lru(挑选最近最少使用的数据淘汰)淘汰策略，留下来的都是经常访问的热点数据</p> <p><strong>Redis的内存用完了会发生什么？</strong></p> <p>主要看数据淘汰策略是什么？如果是默认的配置（ noeviction ），会直接报错</p></div> <h3 id="分布式锁"><a href="#分布式锁" class="header-anchor">#</a> 分布式锁</h3> <p>setnx、redisson</p> <p>分布式锁使用的场景：集群情况下的定时任务、抢单、幂等性场景</p> <p><strong>setnx</strong></p> <p>获取锁</p> <div class="language-java extra-class"><pre class="language-java"><code># 添加锁，<span class="token constant">NX</span>是互斥，<span class="token constant">EX</span>是设置超时时间
<span class="token constant">SET</span> lock value <span class="token constant">NX</span> <span class="token constant">EX</span> <span class="token number">10</span>
</code></pre></div><p>释放锁</p> <div class="language-java extra-class"><pre class="language-java"><code># 释放锁则删除即可
<span class="token constant">DEL</span> key
</code></pre></div><p><strong>redisson</strong></p> <p>redisson实现的分布式锁是可重入的（同一个线程）</p> <ul><li>利用<strong>hash结构</strong>记录<strong>线程id</strong>和<strong>重入次数</strong></li></ul> <table><thead><tr><th style="text-align:center;">KEY</th> <th style="text-align:center;">VALUE_field</th> <th style="text-align:center;">VALUE_value</th></tr></thead> <tbody><tr><td style="text-align:center;">Lock_yzm</td> <td style="text-align:center;">Thread</td> <td style="text-align:center;">1</td></tr></tbody></table> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token class-name">RLock</span> lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">&quot;Lock_yzm&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">boolean</span> isLock <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 执行业务</span>
  <span class="token function">add2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 释放锁</span>
  lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token class-name">RLock</span> lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">&quot;Lock_yzm&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">boolean</span> isLock <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 执行业务</span>
  <span class="token comment">// 释放锁</span>
  lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>redisson实现的分布式锁不能保证主从一致性，但是可以使用红锁</p> <p>集群中有主节点和从节点，主节点写，从节点读，此时线程1对主节点加锁，正常情况下主节点向从节点同步数据，不幸的是，主节点宕机了，此时在从节点中选出新的节点代替原来的主节点，加入线程2来了，对现在的主节点加锁，那么造成了多个线程同时持有锁，就很可能会造成数据的不一致。</p> <p>RedLock（红锁）：不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁（n / 2 + 1），避免在一个redis实例上加锁。</p> <ul><li>实现复杂</li> <li>性能差</li> <li>运维繁琐</li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>redis分布式锁是如何实现的？</strong></p> <p>1、按照简历项目的业务场景描述分布式锁使用的场景</p> <p>2、使用redisson实现的分布式锁，底层使用setnx和lua脚本（保证原子性）</p> <p><strong>Redisson实现分布式锁如何合理地控制锁的有效时长？</strong></p> <p>在redisson的分布式锁中，提供了一个WatchDog（看门狗），一个线程获取锁成功之后，WatchDog会给持有锁的线程续期（默认是每隔10秒续期一次）</p> <p><strong>Redisson的这个锁，可以重入吗？</strong></p> <p>可以重入，多个锁重入需要判断是否是当前线程，在redis中进行存储的时候使用的是<strong>hash结构</strong>来存储<strong>线程信息和重入的次数</strong></p> <p><strong>Redisson锁能解决主从数据一致的问题吗？</strong></p> <p>不能解决，但是可以用redisson提供的红锁来解决，但是这样的话，性能就会很低，如果业务中非要保证数据的强一致性，可以采用zookeeper实现的分布式锁</p></div> <h2 id="其他面试题"><a href="#其他面试题" class="header-anchor">#</a> 其他面试题</h2> <h3 id="集群"><a href="#集群" class="header-anchor">#</a> 集群</h3> <p>主从、哨兵、集群</p> <h4 id="主从模式"><a href="#主从模式" class="header-anchor">#</a> 主从模式</h4> <p>单点Redis的并发能力有限，并且可能会发生宕机，进一步提高并发能力，就需要搭建主从集群，实现读写分离。</p> <p>主从全量同步</p> <p><img src="/docs/assets/Redis/img/all_fsyn.png" alt="all_fsyn"></p> <p>主从增量同步（slave重启或者后期数据变化）</p> <p><img src="/docs/assets/Redis/img/add_fsyn.png" alt="add_fsyn"></p> <p>主从同步的流程</p> <p>全量同步：</p> <ol><li>从节点请求主节点同步数据(replication id、offset)</li> <li>主节点判断是否是第一次请求，是第一次就与从节点同步版本信息(replication id、offset)</li> <li>主节点执行bgsave，生成rdb文件后，发送给从节点去执行</li> <li>在rdb生成期间，主节点会将此时的写操作以命令的方式记录到缓冲区（一个日志文件）</li> <li>把生成之后的命令日志文件发送给从节点进行同步</li></ol> <p>增量同步(slave重启或者后期数据变化)：</p> <ol><li>从节点请求主节点同步数据，主节点判断是否是第一次请求，不是第一次就获取从节点的offset值</li> <li>主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步</li></ol> <h4 id="哨兵模式"><a href="#哨兵模式" class="header-anchor">#</a> 哨兵模式</h4> <p>虽然有了主从同步，但主节点要是挂了，还是需要程序员手动选择从节点升级为主节点提供写入服务，不够智能，为了使其自动化，Redis提供了哨兵(Sentinel)机制来实现主从集群的自动故障恢复。</p> <ul><li>一般有若干个节点组成哨兵Sentinel集群</li> <li>监控：Sentinel会不断检查master和slave是否按预期工作
<ul><li>基于心跳机制检测服务状态，每隔1秒向集群的每个实例发送ping命令
<ul><li>主观下线：如果某sentinel节点发现某实例未在规定时间内响应，则认为该实例<strong>主观下线</strong></li> <li>客观下线：若超过quorum的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong> <ul><li>quorum值最好超过Sentinel实例数量的一半</li></ul></li></ul></li></ul></li></ul> <p><img src="/docs/assets/Redis/img/obj_sub_down.png" alt="obj_sub_down"></p> <ul><li>自动故障恢复：如果master故障，Sentinel会选出一个slave提升为master，故障实例恢复后也以新的master为主
<ul><li>Sentinel领导者选举
<ul><li>使用Raft算法选举
<ul><li>每个在线的Sentinel节点都有资格成为领导者，当它确认主节点主观下线时候，会向其他Sentinel节点发送sentinel is-master-down-by-addr命令，要求将自己设置为领导者。</li> <li>收到命令的Sentinel节点，如果没有同意过其他Sentinel节点的sentinel is-master-down-by-addr命令，将同意该请求，否则拒绝。</li> <li>如果该Sentinel节点发现自己的票数已经大于等于max(quorum,num (sentinels) / 2 + 1)，那么它将成为领导者。</li> <li>如果此过程没有选举出领导者，将进入下一次选举。</li></ul></li></ul></li> <li>主节点挑选规则
<ul><li>过滤：“不健康”（主观下线、断线）、5秒内没有回复过Sentinel节点ping响应、与主节点失联超过指定时间</li> <li>选择<strong>优先级最高</strong>的从节点，<strong>slave-priority</strong>值<strong>越小</strong>优先级越高</li> <li>选择复制<strong>偏移量offset最大</strong>的从节点（复制的最完整）</li> <li>选择运行<strong>id最小</strong>的从节点</li></ul></li></ul></li> <li>通知：Sentinel充当Redis客户端的服务来发现来源，集群发生故障转移时，将最新信息推送给Redis的客户端</li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>怎么保证Redis的高并发高可用？</strong></p> <p>主从+哨兵模式：利用主从模式提高并发性，实现读写分离，哨兵模式实现主从集群的自动故障恢复（监控、自动故障恢复、通知）</p> <p><strong>你们使用的Redis是单点还是集群，哪种集群？</strong></p> <p>主从（1主1从）+哨兵就可以了，单点不超过10G内存（只存热点数据），如果Redis内存不足则可以给不同服务分配独立的Redis主从节点</p> <p><strong>redis集群脑裂，该怎么解决？</strong></p> <p>有时候由于网络等原因可能会出现脑裂的情况，就是说，由于redis master节点和redis salve节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到master，所以通过选举的方式提升了一个salve为master，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在old master那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将old master降为salve，这时再从新master同步数据，这会导致old master中的大量数据丢失。</p> <p>解决：在redis的配置中可以设置：第一可以<strong>设置最少的salve节点个数</strong>，比如设置至少要有一个从节点才能同步数据，第二个可以设置主从数据复制和同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失</p></div> <h4 id="集群模式"><a href="#集群模式" class="header-anchor">#</a> 集群模式</h4> <p>主从和哨兵可用解决高可用、高并发读的问题，但如果有海量数据存储或高并发写时就会出现问题。使用分片集群模式可以解决这个问题。</p> <p>Redis集群通过数据分区来实现数据的分布式存储，通过自动故障转移实现高可用。数据分区是在集群创建的时候完成的。自动故障转移类似于哨兵模式，但此时的集群：</p> <ul><li>有多个master，每个master保存不同的数据</li> <li>每个master都可以有多个slave节点</li> <li>master之间通过ping检测彼此健康状态</li> <li>客户端可以访问集群任意节点，最终都会被转发到正确节点</li></ul> <p><img src="/docs/assets/Redis/img/cluster.png" alt="cluster"></p> <p>分片集群结构的数据读写</p> <p>引入了 <strong>虚拟节点</strong> 的概念。Redis 集群使用的便是该方案，其中的虚拟节点称为 <strong>槽（slot）</strong>。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。</p> <p>在使用了槽的一致性哈希分区中，槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点之间的关系，增加或删除节点对系统的影响很小（只需重新分配少部分节点负责的槽位）。</p> <p>Redis集群中有16384个hash槽，每个key通过hash运算（CRC16）后对16384取模得到其应该放置的槽位，集群中每个节点负责一部分hash槽。</p> <p>tip：可以通过设置有效部分让一部分key放到相同节点。如 <code>set {aaa}name salvatore</code>，此时用aaa计算得到其hash值进而得到其slot即槽位置。</p> <h3 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h3> <p>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</p> <p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(Transaction)功能。</p> <p>Redis提供了简单的事务，但它对事务ACID的支持并不完备。<code>MULTI</code> 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <code>EXEC</code> 命令后，再执行所有的命令。</p> <p>Redis事务的注意点有哪些？</p> <ul><li>Redis 事务是不支持回滚的，不像 MySQL 的事务一样，要么都执行要么都不执行，因此，Redis 事务其实是不满足原子性的。</li> <li>Redis 服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。直到事务命令全部执行完毕才会执行其他客户端的命令。</li> <li>Redis 的三种持久化方式都会存在数据丢失的情况，因此，Redis 事务的持久性也是没办法保证的。</li></ul> <h3 id="redis为什么快"><a href="#redis为什么快" class="header-anchor">#</a> Redis为什么快</h3> <ul><li><p>Redis是纯内存操作，执行速度非常快</p></li> <li><p>采用单线程，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题</p></li> <li><p>使用I/O多路复用模型，非阻塞IO</p></li></ul> <p>Redis是纯内存操作，执行速度非常快，它的性能瓶颈是<strong>网络延迟</strong>而不是执行速度， I/O多路复用模型主要就是实现了高效的网络请求。</p> <p>Redis通过IO多路复用来提高网络性能，并且支持各种不同的多路复用实现，并且将这些实现进行封装， 提供了统一的高性能事件库。</p> <p><img src="/docs/assets/Redis/img/Redis_network_modle.png" alt="Redis_network_modle"></p> <ul><li><p>连接应答处理器</p></li> <li><p>命令回复处理器，在Redis6.0之后，为了提升更好的性能，使用了多线程来处理回复事件</p></li> <li><p>命令请求处理器，在Redis6.0之后，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程</p></li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>解释一下I/O多路复用模型？</strong></p> <p>I/O多路复用是指利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。目前的I/O多路复用都是采用的epoll模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要挨个遍历Socket来判断是否就绪，提升了性能。</p> <p>Redis网络模型就是使用I/O多路复用的基础上结合事件的处理器来应对多个Socket请求。</p> <p>Redis6.0引入多线程来异步处理网络请求，提高网络IO性能（因为影响Redis性能的往往是网络IO），读写线程仍然是单线程（读写在内存中操作，速度很快）。</p></div> <h3 id="看完回答下这些问题"><a href="#看完回答下这些问题" class="header-anchor">#</a> 看完回答下这些问题</h3> <p><img src="/docs/assets/Redis/img/question.png" alt="question"></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2023年7月31日星期一下午4点53分</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.b07d6ba1.js" defer></script><script src="/docs/assets/js/2.733019b2.js" defer></script><script src="/docs/assets/js/16.f8cf6a48.js" defer></script>
  </body>
</html>
